evaluationDependsOn(':hal')
evaluationDependsOn(':ntcore')
evaluationDependsOn(':cscore')
evaluationDependsOn(':cameraserver')

ext {
  baseId = 'wpilibj'
  groupId = 'edu.wpi.first.wpilibj'
  devMain = 'edu.wpi.first.wpilibj.DevMain'
}

apply from: "${rootDir}/shared/java/javacommon.gradle"

def wpilibVersionFileInput = file("src/generate/WPILibVersion.java.in")
def wpilibVersionFileOutput = file("$buildDir/generated/java/edu/wpi/first/wpilibj/util/WPILibVersion.java")

task generateJavaVersion() {
    description = 'Generates the wpilib version class'
    group = 'WPILib'

    outputs.file wpilibVersionFileOutput
    inputs.file wpilibVersionFileInput

    if (WPILibVersion.releaseType.toString().equalsIgnoreCase('official')) {
        outputs.upToDateWhen { false }
    }

    // We follow a simple set of checks to determine whether we should generate a new version file:
    // 1. If the release type is not development, we generate a new verison file
    // 2. If there is no generated version number, we generate a new version file
    // 3. If there is a generated build number, and the release type is development, then we will
    //    only generate if the publish task is run.
    doLast {
        println "Writing version ${WPILibVersion.version} to $wpilibVersionFileOutput"

        if (wpilibVersionFileOutput.exists()) {
            wpilibVersionFileOutput.delete()
        }
        def read = wpilibVersionFileInput.text.replace('${wpilib_version}', WPILibVersion.version)
        wpilibVersionFileOutput.write(read)
    }
}

gradle.taskGraph.addTaskExecutionGraphListener { graph ->
    def willPublish = graph.hasTask(publish)
    if (willPublish) {
        generateJavaVersion.outputs.upToDateWhen { false }
    }
}

sourceSets {
   generated {
        java.srcDir "${buildDir}/generated/java/"
    }
}

compileGeneratedJava {
    dependsOn generateJavaVersion
    classpath = configurations.compile
}

compileJava {
    dependsOn compileGeneratedJava
    source += sourceSets.generated.java
}

classes.dependsOn generateJavaVersion

sourcesJar {
  from sourceSets.generated.allSource
}

outputSourcesJar {
  from sourceSets.generated.allSource
}

dependencies {
    compile project(':hal')
    compile project(':wpiutil')
    compile project(':ntcore')
    compile project(':cscore')
    compile project(':cameraserver')
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'junit:junit:4.12'
    testCompile 'com.google.guava:guava:19.0'
    devCompile project(':hal')
    devCompile project(':wpiutil')
    devCompile project(':ntcore')
    devCompile project(':cscore')
    devCompile project(':cameraserver')
    devCompile sourceSets.main.output
}

apply plugin: 'cpp'
apply plugin: 'edu.wpi.first.NativeUtils'
apply plugin: ExtraTasks
apply from: "${rootDir}/shared/config.gradle"

ext {
  sharedCvConfigs = [ wpilibjDev: [] ]
  staticCvConfigs = [:]
  useJava = true
  useCpp = true
}

apply from: "${rootDir}/shared/opencv.gradle"

model {
  components {
    wpilibjDev(NativeExecutableSpec) {
      sources {
        cpp {
          source {
            srcDirs 'src/dev/native/cpp'
            include '**/*.cpp'
            lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
            lib project: ':cscore', library: 'cscore', linkage: 'shared'
            lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
            lib project: ':hal', library: 'hal', linkage: 'shared'
            lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
          }
          exportedHeaders {
            srcDirs 'src/dev/native/include'
          }
        }
      }
      binaries.all {
        project(':ni-libraries').addNiLibrariesToLinker(it)
      }
    }
  }
  tasks {
    def c = $.components
    project.tasks.create('runCpp', Exec) {
      group = 'WPILib'
      description = "Run the wpilibjDev executable"
      def found = false
      def systemArch = getCurrentArch()
      c.each {
        //println it.name
        if (it in NativeExecutableSpec && it.name == "wpilibjDev") {
          it.binaries.each {
            if (!found) {
              def arch = it.targetPlatform.architecture.name
              if (arch == systemArch) {
                dependsOn it.tasks.install
                commandLine it.tasks.install.runScriptFile.get().asFile.toString()
                def filePath = it.tasks.install.installDirectory.get().toString() + File.separatorChar + 'lib'
                test.dependsOn it.tasks.install
                test.systemProperty 'java.library.path', filePath
                test.workingDir filePath
                run.dependsOn it.tasks.install
                run.systemProperty 'java.library.path', filePath
                run.workingDir filePath

                found = true
              }
            }
          }
        }
      }
    }
  }
}
