evaluationDependsOn(':hal')
evaluationDependsOn(':ntcore')
evaluationDependsOn(':cscore')
evaluationDependsOn(':cameraserver')

ext {
  baseId = 'wpilibj'
  groupId = 'edu.wpi.first.wpilibj'
  devMain = 'edu.wpi.first.wpilibj.DevMain'
}

apply from: "${rootDir}/shared/java/javacommon.gradle"

def versionClass = """
package edu.wpi.first.wpilibj.util;

/*
 * Autogenerated file! Do not manually edit this file. This version is regenerated
 * any time the publish task is run, or when this file is deleted.
 */

public final class WPILibVersion {
  public static final String Version = "${WPILibVersion.version}";
}
""".trim()

def wpilibVersionFile = file('src/main/java/edu/wpi/first/wpilibj/util/WPILibVersion.java')

task generateJavaVersion() {
    description = 'Generates the wpilib version class.'
    group = 'WPILib'

    outputs.file wpilibVersionFile

    if (WPILibVersion.releaseType.toString().equalsIgnoreCase('official')) {
        outputs.upToDateWhen { false }
    }

    // We follow a simple set of checks to determine whether we should generate a new version file:
    // 1. If the release type is not development, we generate a new verison file
    // 2. If there is no generated version number, we generate a new version file
    // 3. If there is a generated build number, and the release type is development, then we will
    //    only generate if the publish task is run.
    doLast {
        println "Writing version ${WPILibVersion.version} to $wpilibVersionFile"

        if (wpilibVersionFile.exists()) {
            wpilibVersionFile.delete()
        }
        wpilibVersionFile.write(versionClass)
    }
}

gradle.taskGraph.addTaskExecutionGraphListener { graph ->
    def willPublish = graph.hasTask(publish)
    if (willPublish) {
        generateJavaVersion.outputs.upToDateWhen { false }
    }
}

clean {
    delete wpilibVersionFile
}

compileJava.dependsOn generateJavaVersion
classes.dependsOn generateJavaVersion

dependencies {
    compile project(':hal')
    compile project(':wpiutil')
    compile project(':ntcore')
    compile project(':cscore')
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'junit:junit:4.12'
    testCompile 'com.google.guava:guava:19.0'
    devCompile project(':hal')
    devCompile project(':wpiutil')
    devCompile project(':ntcore')
    devCompile project(':cscore')
    devCompile sourceSets.main.output
}

apply plugin: 'cpp'
apply plugin: 'edu.wpi.first.NativeUtils'
apply plugin: ExtraTasks
apply from: "${rootDir}/shared/config.gradle"

ext {
  sharedCvConfigs = [ wpilibjDev: [] ]
  staticCvConfigs = [:]
  useJava = true
  useCpp = true
}

apply from: "${rootDir}/shared/opencv.gradle"

model {
  components {
    wpilibjDev(NativeExecutableSpec) {
      sources {
        cpp {
          source {
            srcDirs 'src/dev/native/cpp'
            include '**/*.cpp'
            lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
            lib project: ':cscore', library: 'cscore', linkage: 'shared'
            lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
            lib project: ':hal', library: 'hal', linkage: 'shared'
            lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
          }
          exportedHeaders {
            srcDirs 'src/dev/native/include'
          }
        }
      }
      binaries.all {
        project(':ni-libraries').addNiLibrariesToLinker(it)
      }
    }
  }
  tasks {
    def c = $.components
    project.tasks.create('runCpp', Exec) {
      group = 'WPILib'
      description = "Run the wpilibjDev executable"
      def found = false
      def systemArch = getCurrentArch()
      c.each {
        //println it.name
        if (it in NativeExecutableSpec && it.name == "wpilibjDev") {
          it.binaries.each {
            if (!found) {
              def arch = it.targetPlatform.architecture.name
              if (arch == systemArch) {
                dependsOn it.tasks.install
                commandLine it.tasks.install.runScriptFile.get().asFile.toString()
                def filePath = it.tasks.install.installDirectory.get().toString() + File.separatorChar + 'lib'
                test.dependsOn it.tasks.install
                test.systemProperty 'java.library.path', filePath
                test.workingDir filePath
                run.dependsOn it.tasks.install
                run.systemProperty 'java.library.path', filePath
                run.workingDir filePath

                found = true
              }
            }
          }
        }
      }
    }
  }
}
