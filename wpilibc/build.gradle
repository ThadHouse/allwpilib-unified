apply plugin: 'cpp'
apply plugin: 'google-test'
apply plugin: 'visual-studio'
apply plugin: 'edu.wpi.first.NativeUtils'
apply plugin: SingleNativeBuild
apply plugin: ExtraTasks

ext {
  nativeName = 'wpilibc'
}

apply from: "${rootDir}/shared/config.gradle"

def versionClass = """
/*
 * Autogenerated file! Do not manually edit this file. This version is regenerated
 * any time the publish task is run, or when this file is deleted.
 */
const char* GetWPILibVersion() {
  return "${WPILibVersion.version}";
}
""".trim()

def wpilibVersionFile = file('src/main/native/cpp/WPILibVersion.cpp')

task generateCppVersion() {
    description = 'Generates the wpilib version class'
    group = 'WPILib'

    outputs.file wpilibVersionFile

    if (WPILibVersion.releaseType.toString().equalsIgnoreCase('official')) {
        outputs.upToDateWhen { false }
    }

    // We follow a simple set of checks to determine whether we should generate a new version file:
    // 1. If the release type is not development, we generate a new verison file
    // 2. If there is no generated version number, we generate a new version file
    // 3. If there is a generated build number, and the release type is development, then we will
    //    only generate if the publish task is run.
    doLast {
        println "Writing version ${WPILibVersion.version} to $wpilibVersionFile"

        if (wpilibVersionFile.exists()) {
            wpilibVersionFile.delete()
        }
        wpilibVersionFile.write(versionClass)
    }
}

gradle.taskGraph.addTaskExecutionGraphListener { graph ->
    def willPublish = graph.hasTask(publish)
    if (willPublish) {
        generateCppVersion.outputs.upToDateWhen { false }
    }
}

clean {
    delete wpilibVersionFile
}

model {
  dependencyConfigs {
    opencv(DependencyConfig) {
      groupId = 'org.opencv'
      artifactId = 'opencv-cpp'
      headerClassifier = 'headers'
      ext = 'zip'
      version = '3.2.0'
      sharedConfigs = [ wpilibc: [],
                        wpilibcBase: [],
                        wpilibcDev: [],
                        wpilibcTestingBaseTest: [] ]
    }
  }
  exportsConfigs {
    wpilibc(ExportsConfig) {
      x86ExcludeSymbols = [ '_CT??_R0?AV_System_error', '_CT??_R0?AVexception', '_CT??_R0?AVfailure',
                            '_CT??_R0?AVbad_cast',
                            '_CT??_R0?AVruntime_error', '_CT??_R0?AVsystem_error', '_CTA5?AVfailure',
                            '_TI5?AVfailure' ]
      x64ExcludeSymbols = [ '_CT??_R0?AV_System_error', '_CT??_R0?AVexception', '_CT??_R0?AVfailure',
                            '_CT??_R0?AVbad_cast',
                            '_CT??_R0?AVruntime_error', '_CT??_R0?AVsystem_error', '_CTA5?AVfailure',
                            '_TI5?AVfailure' ]
    }
  }
  components {
    "${nativeName}Base"(NativeLibrarySpec) {
      sources {
        cpp {
          source {
            srcDirs 'src/main/native/cpp'
            include '**/*.cpp'
          }
          exportedHeaders {
            srcDirs 'src/main/native/include'
          }
        }
      }
      binaries.all {
        if (it instanceof SharedLibraryBinarySpec) {
          it.buildable = false
          return
        }
        lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
        lib project: ':cscore', library: 'cscore', linkage: 'shared'
        lib project: ':hal', library: 'hal', linkage: 'shared'
        lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
        lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
        project(':ni-libraries').addNiLibrariesToLinker(it)
      }
    }
    "${nativeName}"(NativeLibrarySpec) {
      sources {
        cpp {
          source {
            srcDirs "${rootDir}/shared/singlelib"
            include '**/*.cpp'
          }
          exportedHeaders {
            srcDirs 'src/main/native/include'
          }
        }
      }
      binaries.all {
        lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
        lib project: ':cscore', library: 'cscore', linkage: 'shared'
        lib project: ':hal', library: 'hal', linkage: 'shared'
        lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
        lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
        project(':ni-libraries').addNiLibrariesToLinker(it)
      }
    }
    // By default, a development executable will be generated. This is to help the case of
    // testing specific functionality of the library.
    if (!project.hasProperty('skipDevExe')) {
      "${nativeName}Dev"(NativeExecutableSpec) {
        sources {
          cpp {
            source {
              srcDirs 'src/dev/native/cpp'
              include '**/*.cpp'
              lib library: 'wpilibc'
            }
            exportedHeaders {
              srcDirs 'src/dev/native/include'
            }
          }
        }
        binaries.all {
          lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
          lib project: ':cscore', library: 'cscore', linkage: 'shared'
          lib project: ':hal', library: 'hal', linkage: 'shared'
          lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
          lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
          project(':ni-libraries').addNiLibrariesToLinker(it)
        }
      }
    }
    // The TestingBase library is a workaround for an issue with the GoogleTest plugin.
    // The plugin by default will rebuild the entire test source set, which increases
    // build time. By testing an empty library, and then just linking the already built component
    // into the test, we save the extra build
    "${nativeName}TestingBase"(NativeLibrarySpec) { }
  }
  testSuites {
    "${nativeName}TestingBaseTest" {
      sources {
        cpp {
          source {
            srcDirs 'src/test/native/cpp'
            include '**/*.cpp'
          }
          exportedHeaders {
            srcDirs 'src/test/native/include', 'src/main/native/cpp'
          }
        }
      }
    }
  }
  binaries {
    all {
      tasks.withType(CppCompile) {
          dependsOn generateCppVersion
      }
    }
    withType(GoogleTestTestSuiteBinarySpec) {
      if (it.component.testedComponent.name.contains('TestingBase') && !project.hasProperty('onlyAthena')) {
        lib project: ':gmock', library: 'gmock', linkage: 'static'
        lib project: ':ntcore', library: 'ntcore', linkage: 'shared'
        lib project: ':cscore', library: 'cscore', linkage: 'shared'
        lib project: ':hal', library: 'hal', linkage: 'shared'
        lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
        lib project: ':cameraserver', library: 'cameraserver', linkage: 'shared'
        project(':ni-libraries').addNiLibrariesToLinker(it)
        lib library: nativeName, linkage: 'shared'
      } else {
        it.buildable = false
      }
    }
  }
  tasks {
    def c = $.components
    project.tasks.create('runCpp', Exec) {
      def found = false
      c.each {
        if (it in NativeExecutableSpec && it.name == "${nativeName}Dev") {
          it.binaries.each {
            if (!found) {
              def arch = it.targetPlatform.architecture.name
              if (arch == 'x86-64' || arch == 'x86') {
                dependsOn it.tasks.install
                commandLine it.tasks.install.runScript
                found = true
              }
            }
          }
        }
      }
    }
  }
}

apply from: 'publish.gradle'
